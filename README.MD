# UISharp
A simple cross-platform UI framework written in C# easy to use and targeting small and mid size projects, especially indie developers projects.
The project is in a minimal viable product state, so it is expected to be expanded with new features, optimizations and code cleanup.

The main project features and goals are:
1. Allow UI development similar to WPF with XAML, but with simplified development process.
   The framework supports writing UI directly in C# (similarly to WinForm but easier to setup) or with a simple yet powerful 
2. Uniform binding, from code to xml definition language, each UI property (size, location, color) is automatically wrapped into
   a `UIProperty<T>` class, enabling data binding and event change notification.
3. Enabled cross platform development, supporting Window, Mac OS (not tested), and Linux.
4. An editor called UIForge allows UI editing automatically generating the UI definition language.
5. The framework is underneath developed using OpenGL for rendering and SDL for event handling, but all the low level
   code is wrapped withing interfaces. The low level wrapping into interface allows using the framework with other rendering technologies,
   such as OpenGL, Vulkan, DirectX, or even software rendering and it also makes UI testing easy with mocking.
6. OpenGL implementation is designed so that it allows integrating the framework with UI components using pure OpenGL, for example
   a game or a 3D animation can be inserted in the UI.
7. Efficient rendering using retained mode via OpenGL instancing (not implemented yet). Each shape is loaded as an OpenGL VAO allowing for fast vectorial rendering (implemented)
   and later on each non-transparent shape will be rendered in bulk using instances (rendering order is guaranteed by depth buffer).
   When a UI component changes a `UIProperty<T>`, the framework is automatically notified and it keeps a list of invalidated objects (implemented) for which the respective
   OpenGL instances in the instance array will be updated (to implement) so allowing retained mode rendering.
# UIForge: the UISharp Editor
UISharp comes with an IDE to define your xml definition file visually.
This is still a small mvp, the UI will significantly improve later. Here's an example of the editor opening calculator.xml, a
UI definition for a simple calculator.
![UISharp IDE](doc/DemoDark.png)
UI Sharp supports both dark theme and light theme natively and it allows changing or extending themes and creating new ones.
Here's an example of the same IDE in light mode.
![UISharp IDE](doc/DemoLight.png)

# Example
Here's the xml UI definition for the calculation example above. The file is generated by the IDE automatically.

```xml
<?xml version="1.0" encoding="utf-8"?>
<window id="calculatorWindow" width="800" height="600">
    <verticallayout backgroundcolor="gray">
        <editbox text="0" margin="10;0;0;0" width="162" />
        <gridlayout rows="4" columns="4" autowidth="wrap" margin="10">
            <button text="7" padding="10" margin="5" />
            <button text="8" margin="5" padding="10" />
            <button text="9" margin="5" padding="10" />
            <button text=":" margin="5" padding="10" />
            <button text="4" margin="5" padding="10" />
            <button text="5" margin="5" padding="10" />
            <button text="6" margin="5" padding="10" />
            <button text="X" margin="5" padding="10" />
            <button text="1" margin="5" padding="10" />
            <button text="2" margin="5" padding="10" />
            <button text="3" margin="5" padding="10" />
            <button text="-" margin="5" padding="10" />
            <button text="C" margin="5" padding="10" />
            <button text="0" margin="5" padding="10" />
            <button text="=" margin="5" padding="10" />
            <button text="+" margin="5" padding="10" />
        </gridlayout>
    </verticallayout>
</window>
```

Here's the main C# class necessary to run the project.
```csharp
internal class Program
{
    static void Main(string[] _)
    {
        using var application = new Application();
        application.Logger.Verbosity = Verbosity.Verbose;
        application.ApplicationStarted += (_, _) => LoadMain(application);
        application.Run();
    }

    private static void LoadMain(Application application)
    {
        application.ShowWindow<CalculatorWindow>();
    }
}
```
And the calculator window code (generated by the developer manually).
Note that in the future binding will be supported so that it may not be necessary to implement any code in the window
class, but a view model could be used instead.

```csharp
internal class CalculatorWindow : Window
{
    private readonly Button _button1;
    private readonly Button _button2;

    public MainWindow(Application parent,
                      Button button1,
                      Button button1, /*etc.*/) : base(parent)
    {
        _button1 = button1;
        _button2 = button2;
        // etc.

        _button1.Action += () => {}; //etc._
    }
}
```

# General Branching Strategies
The branches are as follows:
- `main`: automatic releases and tagging using semantic version. Branch directly from `main` for hot fixes and squash merge.
Later on move to GitFlow.
- `feature/*`: feature branches to merge into release branches.
- `bugfix/*`: critical bug fixes, usually branched to and from `main` directly.
- Other (enhancement, pipeline, etc.): other branches usually branched from and to release branches.

*Branch name*: type/issue number-description
*Commit name*: type #issue number: message

for example
- feature/100-add-button
- refactoring/47-rendering-engine-cleanup
- bugfix/50-fix-issue
- release/v1.0.0

and commits

"Feature #100: fixed issue"
"Refactoring #47: it looks better!"
"Bug #50: it now works!"

pull request messages

"Fixes #100" or "Closes #100" or "Resolves #100" so that pull request merging automatically closes issues.
"References #100" to link issue to PR.
DO NOT add these statements in the PR messages or commit messages because they cause confusion. Add them in the description of PRs.

# Main Design choices
- Do not support backward compatibility because it prevents flexibility
- UISharp.IDE detects the current referenced UISharp version in the target C# project and runs upgrade scripts if necessary, upgrading the project dependency version and all the UIDefinition files.

# Concepts to explain (glossary)
- Component children
  - Canvas (list of shapes)
  - Children (private children directly mapped to UI tree). When deriving a UIObject to not mess up with children unless necessary.
  - Items or Item (logical children or child for layout etc.)
  - Overlays (rendered after Children, they do not contribute to layout calculation so they are separated from Children)
- Binding
  - Two ways, source to destination, destination to source
  - Binding source, binding destination
  - Binding origin, binding target
  - Shallow binding vs deep binding
- Rendering
  - Retained mode
  - Invalidation
  - Render instancing
- Component hierarchy
  - UIComponent
  - UIRoot
  - containers (single and multiple and hierarchical)
- UIDefinition language EAML language

# Class Hierarchy
UIObject -> base class for all UI components
|- UISurface -> base class for windows (maybe actvity too in the future)
|- UIElement -> base class for each window children
   |- UIControl -> base class for all controls (buttons, layout, etc)
     |- UISingleContainer -> controls with one Item
     |- UIContainer -> controls with Items property to add children (e.g. layouts and collections)
     |- UIHierarchicalContainer -> control with hierarchy Items
UIOverlay -> base class for all overlays (popup, tooltip, etc.) and cannot be inserted as Items in windows or layout